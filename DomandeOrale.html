<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Domande Orale</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/contrib/auto-render.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
- **Teorema della gerarchia (spazio)**


- **Teorema di Savitch** e corollario

Data s: N \to N funzione costruibile in spazio tale che log \in O(s) allora
        NSPACE(s) \subseteq DSPACE(s^2)
Consideriamo un linguaggio L \in NSPACE(s) sapendo NSPACE(s) \subseteq NSPACE_1(s)
             si assume \exists MdtN M che riconosce L in spazio s_M \le cs+c, c \in N
Consideriamo M^1 deterministica che riconosce L in spazio s_{M^1} \in O(s^2)
Supponiamo M abbia una sola configurazione d arresto \Xi_h.Sappiamo che la lunghezza delle computazioni di M che ha input x \in L, |x|=n è al massimo 2^{cs(n)+c} per c opportuno( perchè log \in O(s)) e ogni sua configurazione ha dimensione massima cs(n)+c.
Quindi vogliamo mostrare una computazione della configurazione di M da \Xi_0 a \Xi_h che usa spazio O(s^2) e fare in modo che M^1 segua il cammino risultante.

Definiamo il predicato di raggiungibilità in al più k passi tra le configurazioni \beta e \gamma
reach(\beta , \gamma , k) \iff \exists \beta_0 ,...., \beta_j, j \le k \land \beta_0 = \beta \land \beta_j = \gamma \land \forall i=0,....,j-1, \beta_i \vdash_M \beta_{i+1}.
In particolare \forall i:
reach(\beta ,\gamma ,2i) \iff \eists \alfa , reach(\beta , \alfa , i) \land reach(\alfa , \gamma , i)
Quindi reach è ricorsivo allora una Mdt M^1 con input x, |x| \le n puo’ determinare
            reach(\Xi_0 , \Xi_f , 2^{cs(n)+c}
Con al più O(s(n)) chiamate innestate, quindi richiede spazio al più O(s^2)

Come corollario otteniamo quindi che:
            PSPACE = NPSPACE
e poichè le classi deterministiche sono chiuse per complementazione NPSPACE=coNPSPACE
 

 
- **Problema arduo e problema completo**
- **Teorema tempo spazio**
- **Teorema di Cook**
- **Padding**
- **Teorema della proiezione**
- **teorema del punto fisso**
- **Simulazione non determinismo**







- Riducibilità polinomiale
- Modia per dimostrare la NP-completezza
- $A \in NP \cap coNP \land A \text{ è } NP \text{-completo} \implies NP = coNP$
- $NPSPACE = PSPACE$
- $3SAT \le VC$
- $VC \le SAT$
- Gerarchia Polinomiale
- $NP^{PSPACE} = PSPACE$
- HamPath HamCycle
- Insieme indipendente (definizione e riduzione)
- posso testare il costo di una funzione?
- insieme dominante (definizione e riduzione)
- definizione insieme ricorsivamente enumerabile

7.4. Un insieme si dice ricorsivamente enumerabile (r.e.) se o `e vuoto oppure `e il codominio di una funzione totale calcolabile (detta funzione di enumerazione). 


- definizione di insieme produttivo e definizione insieme creativo
10.7. Sia A \subseteq N.

 1. A si dice produttivo se esiste una funzione totale e calcolabile f tale che per ogni i Wi \subseteq A \Rightarrow f(i) \in A\Wi

 2. A si dice creativo se ´e r.e. ed il suo complemento \overline{A}´e produttivo.

-definizione insieme ricorsivo
 
7.1. Un insieme si dice ricorsivo se la sua funzione 
caratteristica `e calcolabile (decidibile)


- teorema di Rice

- definizione di riduzione
- dimostrazione tutti gli insiemi completi sono creativi
- gerarchia polinomiale relativizzata
- relazione tempo spazio
- definizione VC
        <script>
    renderMathInElement(document.body);
  </script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script>
    mermaid.initialize({
      startOnLoad: true
    });
  </script>
        </body>
</html>
